#!/usr/bin/env python3

"""
 The explore node causes the robot to explore the environment autonomously while mapping the world

 SUBSCRIBERS:
  sub_map (nav_msgs/OccupancyGrid) - represents a 2-D grid map, in which each cell represents the probability of occupancy.
"""

import rospy
import actionlib
import numpy as np
from actionlib_msgs.msg import GoalStatus
from move_base_msgs.msg import MoveBaseFeedback, MoveBaseGoal, MoveBaseAction
from nav_msgs.msg import OccupancyGrid
from geometry_msgs.msg import Pose, Point, Quaternion
import random

class Explore:
    
    def __init__(self):
        """ Initialize environment
        """
        self.rate = rospy.Rate(1)

        # self.result = MoveBaseFeedback()

        # Simple Action Client:
        self.move_base = actionlib.SimpleActionClient('move_base', MoveBaseAction)
        self.move_base.wait_for_server()
        rospy.logdebug("move_base is ready") 

        # Initialize subscribers:
        self.map = OccupancyGrid()
        self.sub_map = rospy.Subscriber('/map', OccupancyGrid, self.map_callback)

        # Start the robot moving toward the goal
        self.move()


    def map_callback(self, data):
        """ Callback function for map subscriber.
        Subscribes to /map to get the OccupancyGrid of the map.
        """
        self.map = np.array(data.data).reshape((data.info.height, data.info.width))
        self.map_info = data.info


    def set_goal(self):
        """ Set random goal position for move_base.
        """
        rospy.logdebug("Setting goal")
        # Create goal:
        goal = MoveBaseGoal()

        # Set random goal:
        goal.target_pose.header.frame_id = "map"
        goal.target_pose.header.stamp = rospy.Time.now()
        goal.target_pose.pose.position.x = random.uniform(-10, 10)
        goal.target_pose.pose.position.y = random.uniform(-20, 20)
        goal.target_pose.pose.orientation.w = 1.0

        # Send the goal pose to the MoveBaseAction server
        self.move_base.send_goal(goal)
        rospy.logdebug(f"goal: {goal.target_pose.pose.position.x, goal.target_pose.pose.position.y}")
        rospy.logdebug("Finish setting goal")
        

    def move(self):
        """ Set random goal position for move_base.
        """

        rospy.logdebug("Setting goal")
        # Create goal:
        goal = MoveBaseGoal()

        # Set random goal:
        goal.target_pose.header.frame_id = "map"
        goal.target_pose.header.stamp = rospy.Time.now()
        goal.target_pose.pose.orientation.w = 1.0

        # Send the goal pose to the MoveBaseAction server
        # self.move_base.send_goal(goal)

        rospy.logdebug(f"goal: {goal.target_pose.pose.position.x, goal.target_pose.pose.position.y}")
        rospy.logdebug("Finish setting goal")

        for i in range(20):
            rospy.logdebug(f"Start moving to point {i+1}")

            # Set random goal:
            goal.target_pose.pose.position.x = random.uniform(-10, 10)
            goal.target_pose.pose.position.y = random.uniform(-20, 20)
            self.move_base.send_goal(goal)
            self.move_base.wait_for_result()  
            rospy.logdebug(f"Finish moving to point {i+1}")

        # # Set random goal:
        # self.set_goal()
        # self.move_base.wait_for_result()

        # while not rospy.is_shutdown():
        #     self.count += 1
        #     rospy.logdebug(f"Start looping. count - {self.count}")

        #     state = self.move_base.get_state()
        #     # result = self.move_base.get_result()
        #     # goal_state = self.move_base.get_goal_status_text()
        #     rospy.logdebug(f"state: {state}")
        #     # rospy.logdebug(f"result: {result}")
        #     # rospy.logdebug(f"goal_state: {goal_state}")
            
        #     # # Allow 1 minute to get there
        #     # finished_within_time = self.move_base.wait_for_result(rospy.Duration(60)) 

        #     # # If we don't get there in time, abort the goal
        #     # if (not finished_within_time) or (state == GoalStatus.ABORTED):
        #     #     self.move_base.cancel_goal()
        #     #     rospy.logdebug("Timed out achieving goal")
        #     #     self.set_goal()
        #     # else:
        #     #     # We made it!
        #     #     if state == GoalStatus.SUCCEEDED:
        #     #         rospy.logdebug("Goal succeeded!")
        #     #         self.set_goal()
                    

        #     # If the turtle doesn't get to the goal in time, change goal point
        #     if (self.count > 10) or (state == GoalStatus.ABORTED):
        #         self.move_base.cancel_goal()
        #         rospy.logdebug("Faile achieving goal")
        #         self.set_goal()
        #         self.move_base.wait_for_result()
        #         self.count = 0
        #         self.rate.sleep()

        #     if state == GoalStatus.SUCCEEDED:
        #         rospy.logdebug("Goal succeeded!")
        #         self.set_goal()
        #         self.move_base.wait_for_result()
        #         self.count = 0
        #         self.rate.sleep()

        #     # self.set_goal()
        #     rospy.sleep(1)
        #     # self.rate.sleep()

def main():
    """ The main() function """
    rospy.init_node('explore', log_level=rospy.DEBUG)
    Explore()
    rospy.spin()


if __name__ == '__main__':
    try:
        main()
    except:
        rospy.ROSInterruptException