#!/usr/bin/env python3

"""
 The explore node causes the robot to explore the environment autonomously while mapping the world

 SUBSCRIBERS:
  sub_map (nav_msgs/OccupancyGrid) - represents a 2-D grid map, in which each cell represents the probability of occupancy.
"""

import rospy
import actionlib
import numpy as np
from actionlib_msgs.msg import GoalStatus
from move_base_msgs.msg import MoveBaseFeedback, MoveBaseGoal, MoveBaseAction
from nav_msgs.msg import OccupancyGrid
from geometry_msgs.msg import Pose, Point, Quaternion
import random

class Explore:
    
    def __init__(self):
        """ Initialize environment
        """
        self.rate = rospy.Rate(2)

        # self.result = MoveBaseFeedback()

        # Simple Action Client:
        self.move_base = actionlib.SimpleActionClient('move_base', MoveBaseAction)
        
        # Initialize subscribers:
        self.map = OccupancyGrid()
        self.sub_map = rospy.Subscriber('/map', OccupancyGrid, self.map_callback)
        self.sub_feedback = rospy.Subscriber('/move_base/feedback', MoveBaseAction, self.feedback_callback)

        while not rospy.is_shutdown():
            # Create goal:
            goal = MoveBaseGoal()

            # Set goal:
            goal.target_pose.header.frame_id = "map"
            goal.target_pose.header.stamp = rospy.Time.now()
            goal.target_pose.pose.position.x = random.randint(-10, 10)
            goal.target_pose.pose.position.y = random.randint(-20, 20)
            goal.target_pose.pose.orientation.w = 1.0

            # Start the robot moving toward the goal
            self.move(goal)


    def map_callback(self, data):
        """ Callback function for map subscriber.
        Subscribes to /map to get the OccupancyGrid of the map.
        """
        self.map = np.array(data.data).reshape((data.info.height, data.info.width))
        self.map_info = data.info


    def feedback_callback(self,data):
        """ Callback function for feedback subscriber.
        Subscribes to /move_base/feedback to get the MoveBaseAction of move_base.
        """
        self.position = data.feedback.base_position.pose


    def move(self, goal):
        # Start listner:
        self.move_base.wait_for_server(rospy.Duration(60))
        rospy.logdebug("move_base is ready") 

        # Send the goal pose to the MoveBaseAction server
        # rospy.logdebug(f"Sending goal")
        self.move_base.send_goal(goal)

        # # Allow 1 minute to get there
        # rospy.logdebug(f"Moving")
        finished_within_time = self.move_base.wait_for_result(rospy.Duration(60)) 
        
        # If we don't get there in time, abort the goal
        if not finished_within_time:
            self.move_base.cancel_goal()
            rospy.loginfo("Timed out achieving goal")

        else:
            # We made it!
            state = self.move_base.get_state()
            if state == GoalStatus.SUCCEEDED:
                rospy.loginfo("Goal succeeded!")

        # # Send the goal pose to the MoveBaseAction server
        # self.move_base.send_goal(goal)

        # state = self.move_base.get_state()
        # while state != 3:
        #     state = self.move_base.get_state()
        #     rospy.logerr(state)
        #     self.rate.sleep()


def main():
    """ The main() function. """
    rospy.init_node('explore', log_level=rospy.DEBUG)
    Explore()
    rospy.spin()
    # while not rospy.is_shutdown():
    #     rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except:
        rospy.ROSInterruptException